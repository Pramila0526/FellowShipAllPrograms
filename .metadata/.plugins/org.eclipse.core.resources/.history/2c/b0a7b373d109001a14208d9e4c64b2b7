package com.bridgelabz.fellowshipprogramss.utility;
class BinarySearchTree
{
	Node root;
class Node {
int key;
Node left, right;

public Node(int item) {
key = item;
left = right = null;
}
}

// Root of BST


// Constructor
/*BinarySearchTree() {
root = null;*/

public Node search(Node root, int key)
{
    // Base Cases: root is null or key is present at root
    if (root==null || root.key==key)
        return root;
 
    // val is greater than root's key
    if (root.key > key)
        return search(root.left, key);
 
    // val is less than root's key
    return search(root.right, key);
}
// This method mainly calls insertRec()
void insert(int key) {
root = insertRec(root, key);
}

/* A recursive function to insert a new key in BST */
Node insertRec(Node root, int key) {

/* If the tree is empty, return a new node */
if (root == null) {
root = new Node(key);
return root;
}

/* Otherwise, recur down the tree */
if (key < root.key)
root.left = insertRec(root.left, key);
else if (key > root.key)
root.right = insertRec(root.right, key);

/* return the (unchanged) node pointer */
return root;
}

// This method mainly calls InorderRec()
void inorder() 
{
inorderRec(root);
}

// A utility function to do inorder traversal of BST
void inorderRec(Node root) 
{
if (root != null) 
{
 
inorderRec(root.left);
System.out.println(root.key);
inorderRec(root.right);
}
}
}
// Driver Program to test above functions
public static void main(String[] args) 
{
BinarySearchTree tree = new BinarySearchTree();
int count=0;
tree.insert(50);
count++;
tree.insert(30);
count++;
tree.insert(20);
count++;
tree.insert(40);
count++;
tree.insert(70);
count++;
tree.insert(60);
count++;
tree.insert(80);
count++;
   
tree.inorder();
System.out.println(count);
//int a[]=new int[1000];
/*a[0]=1;
a[1]=1;
for(int i=2;i<count;i++)
{
	for(int j=1;j<count;j++)
		
{
	a[i]=a[i]+a[j-1]*a[count-j];
}

System.out.println(a[i]);*/
public static int bCount(count)
{
int n=3;
int n1,n2;
int result=0;
if(count==1 || count==0)
{
	System.out.println(1);
}
for(int i=1;i<=n;i++)
{
	n1=(i-1);
	n2=(n-i);
	result +=n1*n2;
	
}
System.out.println(result);
}
}